<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6553804345739521" crossorigin="anonymous"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google-adsense-account" content="ca-pub-6553804345739521" />
    <meta name="description" content="Extract images from PDF files and download as ZIP. Free tool extracts embedded pictures (JPG/PNG)  browser-based, no uploads." />
  <title>Extract Images - EDITSMYPDF</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/styles.css" />
  <link rel="canonical" href="https://editmypdf.tech/features/extract-images.html" />    <link rel="icon" type="image/png" href="../assets/images/sflogoPNG.PNG" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
      * { box-sizing: border-box; }
      main.feature { max-width: 820px; }
      .extract-card { max-width:760px; margin:0 auto; padding:2.5rem; }
      .extract-card .upload-box { margin-top:.5rem; margin-bottom:1.5rem; min-height:160px; display:flex; align-items:center; justify-content:center; font-size:1.05rem; }
      .images-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:1rem; margin-top:1.25rem; }
      .img-item { position:relative; background:#fafafa; border:1px solid #eee; border-radius:12px; padding:.5rem; box-shadow:0 1px 4px rgba(0,0,0,.06); animation:fadeIn .5s ease; }
      .img-item canvas, .img-item img { width:100%; height:auto; display:block; border-radius:8px; }
      .img-meta { font-size:.7rem; color:#555; margin-top:.35rem; line-height:1.1; }
      .select-toggle { position:absolute; top:6px; right:6px; background:rgba(0,0,0,.55); color:#fff; border:none; border-radius:8px; padding:4px 6px; font-size:.65rem; cursor:pointer; }
      .img-item.selected { outline:2px solid var(--accent); outline-offset:2px; }
      .actions-row { display:flex; flex-wrap:wrap; gap:.75rem; justify-content:center; margin-top:1.25rem; }
      .actions-row button { flex:1 1 220px; }
      @media (max-width:640px){ .actions-row button{ width:100%; } }
      .hint { font-size:.8rem; color:#777; margin-top:.5rem; }

      /* Scoped styles for embedded Extract Images guide */
      .feature-blog {
        max-width: 700px;
        margin: 3rem auto;
        padding: 2rem;
        background: linear-gradient(135deg, #f8faff 0%, #f0f4ff 100%);
        border-left: 5px solid #2563eb;
        border-radius: 16px;
        box-shadow: 0 4px 16px rgba(37, 99, 235, 0.08);
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        line-height: 1.7;
        color: #334155;
      }

      .feature-blog h3 {
        font-size: 1.75rem;
        font-weight: 700;
        color: #1e40af;
        margin: 0 0 1.5rem;
        line-height: 1.3;
      }

      .feature-blog .hero-img {
        width: 100%;
        height: auto;
        border-radius: 12px;
        margin: 1.5rem 0;
        box-shadow: 0 6px 20px rgba(37, 99, 235, 0.12);
        border: 1px solid #e0e7ff;
      }

      .feature-blog section {
        margin: 2rem 0;
      }

      .feature-blog h4 {
        font-size: 1.25rem;
        font-weight: 600;
        color: #1e40af;
        margin: 1.5rem 0 0.75rem;
      }

      .feature-blog p {
        margin: 0.75rem 0;
        color: #475569;
      }

      .feature-blog strong {
        color: #334155;
        font-weight: 600;
      }

      .feature-blog ul {
        margin: 0.75rem 0;
        padding-left: 1.5rem;
      }

      .feature-blog li {
        margin: 0.5rem 0;
        color: #475569;
      }

      .feature-blog .note {
        background: white;
        border: 1px solid #e0e7ff;
        border-radius: 12px;
        padding: 1.25rem;
        margin: 1.5rem 0;
      }

      .feature-blog .note p {
        margin: 0;
      }

      .feature-blog .note a {
        color: #2563eb;
        text-decoration: none;
        font-weight: 600;
      }

      .feature-blog .note a:hover {
        text-decoration: underline;
      }

      .feature-blog .faq {
        margin: 2rem 0 0;
      }

      .feature-blog .faq h4 {
        font-size: 1.35rem;
        margin-bottom: 1rem;
      }

      .feature-blog details {
        background: white;
        border: 1px solid #e0e7ff;
        border-radius: 10px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .feature-blog details:hover {
        border-color: #c7d2fe;
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.08);
      }

      .feature-blog summary {
        font-weight: 600;
        color: #1e40af;
        list-style: none;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .feature-blog summary::-webkit-details-marker {
        display: none;
      }

      .feature-blog summary::before {
        content: '‚ñ∂';
        font-size: 0.75rem;
        transition: transform 0.2s ease;
        color: #2563eb;
      }

      .feature-blog details[open] summary::before {
        transform: rotate(90deg);
      }

      .feature-blog details p {
        margin-top: 0.75rem;
        padding-left: 1.25rem;
      }

      @media (max-width: 640px) {
        .feature-blog {
          margin: 2rem 1rem;
          padding: 1.5rem;
        }

        .feature-blog h3 {
          font-size: 1.5rem;
        }

        .feature-blog h4 {
          font-size: 1.15rem;
        }
      }
    </style>
  </head>
  <body>
    <header data-include="navbar"></header>
    <div id="ad-top" class="ad-slot"></div>
  <main class="feature">
      <h2>Extract Images</h2>
      <p class="sub">Pull embedded raster images from your PDF pages. Processing is 100% local.</p>
      <div class="card feature-enter extract-card">
        <label class="upload-box" id="drop-zone">üìÑ Drop PDF or click to upload
          <input type="file" id="file-input" accept="application/pdf" style="display:none" />
        </label>
        <div class="controls">
          <select id="format">
            <option value="png" selected>PNG</option>
            <option value="jpeg">JPEG</option>
          </select>
          <select id="scale">
            <option value="1">Scale 1x</option>
            <option value="1.5" selected>Scale 1.5x</option>
            <option value="2">Scale 2x</option>
          </select>
        </div>
        <div id="status" class="progress"></div>
        <div class="hint">Note: Some PDFs embed vector graphics instead of raster images; only raster XObjects are extractable here.</div>
        <div id="images" class="images-grid"></div>
        <div class="actions-row">
          <button id="download-selected" class="primary" disabled>Download Selected</button>
          <button id="download-zip" class="primary" disabled>Download All ZIP</button>
        </div>
      </div>
    <div id="ad-content" class="ad-slot"></div>

    <!-- Feature Blog Section -->
    <section class="feature-blog">
      <div class="title-with-logo">
        <img src="../assets/images/sflogoPNG.PNG" alt="PDF Tools Logo" class="brand-logo" />
        <h3> Extract Images from PDFs  Save Embedded Pictures Instantly</h3>
      </div>

      <img src="../assets/images/extract image.JPG" alt="Extract images from PDF" class="hero-img" />

      <section>
        <h4>How It Works</h4>
        <p>Our <strong>Extract Images tool</strong> It employs advanced PDF rendering methods. These methods scan every page in the document. They identify embedded raster images, such as photos, logos, and diagrams. Users have options for the output format. They can select PNG or JPEG as preferred. It is possible to choose specific images only. Alternatively, everything can go into a single ZIP file for download. All the processing occurs locally within the browser itself. No external servers get involved. This keeps things secure and quick.</p>
      </section>

      <section>
        <h4>Why Use This Tool?</h4>
        <ul>
          <li><strong>Selective Extraction:</strong> Preview all images and download only what you need</li>
          <li><strong>Format Choice:</strong> Export as PNG (lossless quality) or JPEG (smaller file size)</li>
          <li><strong>Batch Downloads:</strong> Get all images in one ZIP archive with a single click</li>
          <li><strong>100% Private:</strong> No uploads, no tracking  everything happens in your browser</li>
          <li><strong>High Resolution:</strong> Scale images up to 2 for sharper exports</li>
        </ul>
      </section>

      <section>
        <h4>Complete Privacy</h4>
        <p>Your PDF <strong>never leaves your device</strong>. We use client-side JavaScript (PDF.js + JSZip) to render pages and extract images locally. No server uploads, no data retention, no privacy concerns.</p>
      </section>

      <section>
        <h4>PNG vs JPEG: Which Format Should You Choose?</h4>
        <p><strong>PNG:</strong> Best for logos, diagrams, screenshots, and images with transparency. Lossless quality but larger file sizes.</p>
        <p><strong>JPEG:</strong> Ideal for photos and images where file size matters. Slight compression reduces quality but creates smaller downloads.</p>
        <p><strong>Pro Tip:</strong> Use PNG for text-heavy images (charts, infographics) and JPEG for photographs.</p>
      </section>

      <section>
        <h4>Extraction Tips</h4>
        <p>Extracting images from PDFs is pretty straightforward, but knowing a few tricks will save you time and frustration. Here's what you need to know:</p>
        <ul>
          <li><strong>Vector vs Raster Explained:</strong> This tool extracts only raster images from PDFs. These include formats such as JPEGs, PNGs, and typical photographs. Evidence indicates that if a PDF relies solely on vector graphics, like those created in Illustrator for logos or basic shapes in design programs, the tool will detect no extractable images. Vector graphics rely on mathematical paths rather than pixels. As a result, they do not qualify as raster images for extraction purposes. When the message states no raster images were found, it suggests the document probably features vectors exclusively. Studies on digital file formats show this distinction often leads to such outcomes in image processing tasks. Professional context in graphic design highlights how vectors maintain scalability without quality loss. Yet raster images, being pixel-based, suit photographic content better. This separation ensures tools like this one focus on appropriate file types efficiently.</li>
          <li><strong>Scale for Higher Resolution:</strong> The default setting sticks with a 1x scale most of the time. It pulls images straight from their built-in resolution without any changes. When higher quality matters for things like printing or blowing up the size, people often switch to 1.5x or 2x instead. Those choices render everything at a bigger dimension overall. That setup works well for slipping the images into presentations or posters, even marketing pieces that need to stand out. Still, keep in mind higher scales always lead to much larger files in the end.</li>
          <li><strong>Blurry Images Mean Low Source Quality:</strong> When images pulled from a PDF look blurry or pixelated, it usually means the source file had low-resolution versions to start with. That issue stays put no matter what. Trying to scale them up just does not add any real sharpness past the original limits in the document. It works much the same as zooming in on a grainy picture from way back. No trick can create details that simply were not captured at the beginning..</li>
          <li><strong>Batch Processing Saves Clicks:</strong>When a PDF file includes lots of images, it makes no sense to click on every single thumbnail one by one. People end up wasting too much time that way. Instead, look for the Download as ZIP option and hit that button. It pulls together all the images into one neat archive right away. The file gets saved as extracted-images.zip, holding onto each and every picture from the original PDF. Things like organizing them afterward turn out to be a lot simpler..</li>
          <li><strong>Format Choice Matters:</strong>If you're extracting logos or graphics that have transparent backgrounds, you must use PNG format. JPEG doesn't support transparency and will replace it with a solid color (usually white or black), which ruins the look. Always preview before downloading if transparency matters.</li>
          <li><strong>Check Transparency Needs:</strong> When pulling out logos or graphics with see through backgrounds, stick to PNG files every time. JPEG just cannot handle that kind of transparency at all. It ends up filling in the empty spots with some solid color, often white or black, and that messes up the whole design pretty badly. Check a preview first if keeping things transparent really counts for you.</li>
        </ul>
      </section>

      <section>
        <h4>üñºÔ∏è When Image Extraction is Useful</h4>
        <p>Not sure when you'd need to pull images out of a PDF? Here are some common scenarios where this tool really shines:</p>
        <p><strong>Reusing Graphics for Presentations:</strong>Someone gets a PDF report full of nice charts or infographics. They figure, why not pull those into their own PowerPoint or Google Slides setup. Taking screenshots just ends up looking all pixelated and rough. Better to grab the images straight out at full quality. Drop them right into the slides after that. Things come out looking sharp and put together.</p>
        <p><strong>Saving Product Photos from Catalogs:</strong>Someone gets a PDF report full of nice charts or infographics. They figure, why not pull those into their own PowerPoint or Google Slides setup. Taking screenshots just ends up looking all pixelated and rough. Better to grab the images straight out at full quality. Drop them right into the slides after that. Things come out looking sharp and put together. </p>
        <p><strong>Recovering Images from Old Documents:</strong>Suppose you come across an old PDF file. It could be a newsletter or brochure from way back. Maybe its an archived document too. Anyway, there are photos in it that you really need now. The problem is, the original image files seem to be lost for good. Still, you can extract those visuals directly from the PDF itself. That way, you recover them without any drop in quality at all.</p>
        <p><strong>Building Image Libraries:</strong> If you're collecting visuals from multiple PDF sources (research papers, reports, design mockups), extraction lets you pull all images into a centralized folder for easier management, tagging, and searching.</p>
        <p><strong>Pro tip:</strong> If you only need images from specific pages of a large PDF, use our <a href="./split.html">Split PDF tool</a> first to extract just those pages. Then run the image extraction on the smaller PDF‚Äîit's faster and won't clutter your results with images you don't need.</p>
      </section>

      <section>
        <h4>Quick Guide</h4>
        <p><strong>1. Upload PDF:</strong> Drag and drop or click to select your PDF file</p>
        <p><strong>2. Choose Format:</strong> Select PNG (quality) or JPEG (smaller size)</p>
        <p><strong>3. Select Scale:</strong> Pick 1, 1.5, or 2 resolution</p>
        <p><strong>4. Preview Images:</strong> Wait while the tool scans all pages and displays extracted images</p>
        <p><strong>5. Download:</strong> Click individual images to download, or use "Pick" to select multiple, or click "Download as ZIP" for all images at once</p>
      </section>

      <div class="faq">
        <h4>Frequently Asked Questions</h4>

        <details>
          <summary>Will this extract vector graphics or text?</summary>
          <p>No, this tool only extracts embedded raster (bitmap) images like JPEGs and PNGs. Vector graphics, text, and shapes drawn directly in the PDF won't appear. If you see "No raster images found," your PDF likely contains only vectors.</p>
        </details>

        <details>
          <summary>Should I choose PNG or JPEG format?</summary>
          <p>Use <strong>PNG</strong> for logos, screenshots, diagrams, or any image with transparency or sharp text. Use <strong>JPEG</strong> for photographs where file size matters more than perfect quality. PNG is lossless; JPEG applies compression.</p>
        </details>

        <details>
          <summary>Will the images be the original quality?</summary>
          <p>Yes, we export at the image's native resolution. However, if the original PDF contains low-resolution images, the extracted files will also be low-res. Scaling (1.5 or 2) enlarges the image but won't add detail beyond the source quality.</p>
        </details>

        <details>
          <summary>Can I extract images with transparent backgrounds?</summary>
          <p>Yes, but only if you choose <strong>PNG format</strong>. JPEG doesn't support transparency, so transparent areas will be filled with a solid color (usually white or black). Always use PNG for images with transparency.</p>
        </details>

        <details>
          <summary>What if extracted images look blurry or pixelated?</summary>
          <p>The original PDF likely includes images at low resolution. The extraction tool retrieves these images precisely as they appear embedded in the document. Adjusting the scale factor to 1.5 or 2 enlarges the image dimensions. Yet sharpness remains unchanged in such cases. Evidence from document processing shows that quality improvements cannot exceed the inherent resolution of the source material. This limitation often arises in workflows involving scanned or compressed files.</p>
        </details>

        <details>
          <summary>How do I download all images at once?</summary>
          <p>Use the <strong>"Download as ZIP"</strong> button at the bottom of the images grid. This bundles all extracted images into a single ZIP archive, saving you from clicking each image individually. The ZIP file will be named <code>extracted-images.zip</code>.</p>
        </details>
      </div>

      <div class="note">
        <p><strong>Ready to save those images?</strong> <a href="#file-input">Try it now </a></p>
      </div>
    </section>

    <script>
      // Configure PDF.js worker (prevents errors and major slowdowns)
      const pdfjsLib = window["pdfjs-dist/build/pdf"] || window.pdfjsLib;
      if (pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
      }
      // "Try it now" link functionality
      document.addEventListener('DOMContentLoaded', () => {
        const tryNowLinks = document.querySelectorAll('a[href="#file-input"]');
        tryNowLinks.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
              fileInput.click();
              setTimeout(() => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
              }, 100);
            }
          });
        });
      });

  const dropZone = document.getElementById('drop-zone');
  const fileInput = document.getElementById('file-input');
  const imagesGrid = document.getElementById('images');
  const statusText = document.getElementById('status');
  const dlSelBtn = document.getElementById('download-selected');
  const dlZipBtn = document.getElementById('download-zip');
  const fmtSel = document.getElementById('format');
  const scaleSel = document.getElementById('scale');
      let extracted = []; // {name, dataUrl, selected}

      dropZone.addEventListener('dragover', e=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
      dropZone.addEventListener('dragleave', ()=> dropZone.classList.remove('dragover'));
      dropZone.addEventListener('drop', async e=>{ e.preventDefault(); dropZone.classList.remove('dragover'); const f=e.dataTransfer.files[0]; if(f) await processPDF(f); });
      fileInput.addEventListener('change', async e=>{ const f=e.target.files[0]; if(f) await processPDF(f); e.target.value=''; });

      function reset(){ extracted=[]; imagesGrid.innerHTML=''; dlSelBtn.disabled=true; dlZipBtn.disabled=true; statusText.textContent=''; }
      function updateButtons(){ dlSelBtn.disabled = !extracted.some(x=>x.selected); dlZipBtn.disabled = !extracted.length; }

      async function processPDF(file){
        reset(); statusText.textContent='Loading PDF...';
        const bytes = new Uint8Array(await file.arrayBuffer());
        const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
        statusText.textContent='Scanning pages for images...';
        for (let pageNum=1; pageNum<=pdf.numPages; pageNum++){
          const page = await pdf.getPage(pageNum);
          // Render page offscreen (ensures image objects are decoded & cached)
          const scale = parseFloat(scaleSel.value) || 1.5;
          const viewport = page.getViewport({ scale });
          const opList = await page.getOperatorList();
          const OPS = pdfjsLib.OPS;
          const imagesToExtract = []; // entries: { type:'xobj'|'inline', name?, obj?, width?, height?, data? }

          for (let i=0;i<opList.fnArray.length;i++){
            const fn = opList.fnArray[i];
            const args = opList.argsArray[i];
            if (fn === OPS.paintImageXObject || fn === OPS.paintImageXObjectRepeat || fn === OPS.paintJpegXObject) {
              if (args && args[0]) imagesToExtract.push({ type:'xobj', name: args[0] });
            } else if (fn === OPS.paintInlineImageXObject) {
              // Inline image; args[0] often contains an object with image data/size
              if (args && args[0]) imagesToExtract.push({ type:'inline', obj: args[0] });
            }
          }

          await page.render({ canvasContext: document.createElement('canvas').getContext('2d'), viewport }).promise;

          const formatMime = fmtSel.value === 'jpeg' ? 'image/jpeg' : 'image/png';
          const ext = fmtSel.value === 'jpeg' ? 'jpg' : 'png';

          // Helper: normalize raw data to RGBA regardless of source stride
          function toRGBA(data, w, h){
            const pixels = w * h;
            const len = data ? data.length : 0;
            const stride = pixels ? Math.round(len / pixels) : 0; // 1, 2, 3, 4 are common
            const out = new Uint8ClampedArray(pixels * 4);
            if (!data || !pixels) return out;
            if (stride === 4){
              out.set(data);
              return out;
            }
            if (stride === 3){
              for (let i=0, j=0; i<pixels; i++, j+=3){
                const r=data[j], g=data[j+1], b=data[j+2];
                const k=i*4; out[k]=r; out[k+1]=g; out[k+2]=b; out[k+3]=255;
              }
              return out;
            }
            if (stride === 2){ // grayscale + alpha
              for (let i=0, j=0; i<pixels; i++, j+=2){
                const g=data[j], a=data[j+1];
                const k=i*4; out[k]=g; out[k+1]=g; out[k+2]=g; out[k+3]=a;
              }
              return out;
            }
            if (stride === 1){ // grayscale
              for (let i=0; i<pixels; i++){
                const g=data[i]; const k=i*4; out[k]=g; out[k+1]=g; out[k+2]=g; out[k+3]=255;
              }
              return out;
            }
            // Fallback: assume RGBA if unknown
            out.set(data.subarray(0, out.length));
            return out;
          }

          for (const entry of imagesToExtract){
            try {
              let baseCanvas = document.createElement('canvas');
              const baseCtx = baseCanvas.getContext('2d');
              let w=0, h=0;

              if (entry.type === 'xobj') {
                const imgObj = page.objs.get(entry.name);
                if (!imgObj) continue;
                if (imgObj.data && imgObj.width && imgObj.height) {
                  // Raw pixel data (may be 1/2/3/4 bytes per pixel)
                  w = imgObj.width; h = imgObj.height;
                  baseCanvas.width = w; baseCanvas.height = h;
                  const rgba = toRGBA(imgObj.data, w, h);
                  const imageData = new ImageData(rgba, w, h);
                  baseCtx.putImageData(imageData, 0, 0);
                } else if (imgObj instanceof ImageBitmap || imgObj instanceof HTMLImageElement || imgObj instanceof HTMLCanvasElement) {
                  w = imgObj.width; h = imgObj.height;
                  baseCanvas.width = w; baseCanvas.height = h;
                  baseCtx.drawImage(imgObj, 0, 0);
                } else if (imgObj && imgObj.bitmap) {
                  // Some builds expose { bitmap: ImageBitmap }
                  const bmp = imgObj.bitmap; w = bmp.width; h = bmp.height;
                  baseCanvas.width = w; baseCanvas.height = h;
                  baseCtx.drawImage(bmp, 0, 0);
                } else {
                  continue;
                }
              } else if (entry.type === 'inline') {
                const o = entry.obj;
                if (o && o.width && o.height && (o.data || o._data)) {
                  w = o.width; h = o.height;
                  baseCanvas.width = w; baseCanvas.height = h;
                  const raw = (o.data && o.data.length) ? o.data : (o._data || new Uint8ClampedArray(w*h*4));
                  const rgba = toRGBA(raw, w, h);
                  const imageData = new ImageData(rgba, w, h);
                  baseCtx.putImageData(imageData, 0, 0);
                } else if (o instanceof ImageBitmap || o instanceof HTMLImageElement || o instanceof HTMLCanvasElement) {
                  w = o.width; h = o.height;
                  baseCanvas.width = w; baseCanvas.height = h;
                  baseCtx.drawImage(o, 0, 0);
                } else {
                  continue;
                }
              }

              // Apply optional scaling for output
              let outCanvas = baseCanvas;
              if (scale && scale !== 1) {
                const scaled = document.createElement('canvas');
                scaled.width = Math.max(1, Math.round(w * scale));
                scaled.height = Math.max(1, Math.round(h * scale));
                const sctx = scaled.getContext('2d');
                sctx.imageSmoothingEnabled = true;
                sctx.imageSmoothingQuality = 'high';
                sctx.drawImage(baseCanvas, 0, 0, scaled.width, scaled.height);
                outCanvas = scaled;
              }

              const dataUrl = outCanvas.toDataURL(formatMime, 0.92);
              const name = entry.type === 'xobj' && entry.name ? `p${pageNum}-${entry.name}.${ext}` : `p${pageNum}-inline-${extracted.length + 1}.${ext}`;

              const item = { name, dataUrl, selected:false };
              extracted.push(item);

              // UI card
              const div = document.createElement('div');
              div.className='img-item';
              const imgtag = document.createElement('img');
              imgtag.src = dataUrl; imgtag.alt = item.name;
              const meta = document.createElement('div'); meta.className='img-meta'; meta.textContent = `${item.name}\n${w}x${h}`;
              const toggle = document.createElement('button'); toggle.className='select-toggle'; toggle.textContent='Pick';
              toggle.addEventListener('click', ()=>{ item.selected = !item.selected; div.classList.toggle('selected', item.selected); toggle.textContent = item.selected? '‚úì' : 'Pick'; updateButtons(); });
              div.appendChild(imgtag); div.appendChild(meta); div.appendChild(toggle); imagesGrid.appendChild(div);
            } catch(e){ /* ignore single extraction failure and continue */ }
          }
          statusText.textContent = `Page ${pageNum}/${pdf.numPages} scanned. Total images: ${extracted.length}`;
        }
        if (!extracted.length){ statusText.textContent += ' ‚Äî No raster images found.'; }
        updateButtons();
      }

      dlSelBtn.addEventListener('click', ()=>{
        extracted.filter(x=>x.selected).forEach(x=> triggerDownload(x.dataUrl, x.name));
      });

      dlZipBtn.addEventListener('click', async ()=>{
        if (!extracted.length) return;
        statusText.textContent='Preparing ZIP...';
        const zip = new JSZip();
        extracted.forEach(x=> zip.file(x.name, x.dataUrl.split(',')[1], { base64:true }));
        const blob = await zip.generateAsync({ type:'blob' });
        triggerBlobDownload(blob, 'extracted-images.zip');
        statusText.textContent='ZIP downloaded.';
      });

      function triggerDownload(dataUrl, filename){
        const a = document.createElement('a'); a.href=dataUrl; a.download=filename; a.click(); }
      function triggerBlobDownload(blob, filename){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url); }
    </script>
    <script src="../assets/app.js"></script>
  </body>
</html>
